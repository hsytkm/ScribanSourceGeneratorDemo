# ScribanSourceGeneratorDemo

Create source code using [ScribanSourceGenerator](https://github.com/ufcpp/ScribanSourceGenerator)
 without T4 TextTemplate.

## Example 1

**Source code**

```cs
namespace ScribanSourceGeneratorDemo;
[ScribanSourceGenerator.ClassMember("""
    {{
    $types = ["bool","byte","sbyte","short","ushort","int","uint","long","ulong","float","double","DateTime","DateTimeOffset","TimeSpan"]
    for $t in $types
    ~}}
        public static bool TryParse(this string s, out {{$t}} x) => {{$t}}.TryParse(s, out x);
    {{ end }}
    """)]
public static partial class ScribanDemo1 { }
```

**Generated code**

```cs
// <auto-generated/>
namespace ScribanSourceGeneratorDemo {
partial class ScribanGenDemo1 {
    public static bool TryParse(this string s, out bool x) => bool.TryParse(s, out x);
    public static bool TryParse(this string s, out byte x) => byte.TryParse(s, out x);
    ...
}}
```

## Example 2

**Source code**

```cs
[ScribanSourceGenerator.ClassMember("""
    {{
    func get_words(max,words...);
      $s1 = "";
      for $i in 1..max
        $s2 = "";
        for $w in words
          $s2 += $w 
          # Do not join index at the end.
          if !for.last; $s2 += $i; end
        end
        $s1 += $s2
        if !for.last
            $s1 += ", "
        end
      end
      ret $s1;
    end
    -}}
    {{ for $i in 2..4 ~}}
        public static async Task<({{ get_words $i "T" "" }})> WhenAll<{{ get_words $i "T" "" }}>({{ get_words $i "Task<T" "> task" "" }})
        {
            await Task.WhenAll({{ get_words $i "task" "" }});
            return ({{ get_words $i "task" ".Result" }});
        }
    {{ end }}
    """)]
public static partial class ScribanDemo2 { }
```

**Generated code**

```cs
// <auto-generated/>
namespace ScribanSourceGeneratorDemo {
partial class ScribanGenDemo2 {
    public static async Task<(T1, T2)> WhenAll<T1, T2>(Task<T1> task1, Task<T2> task2)
    {
        await Task.WhenAll(task1, task2);
        return (task1.Result, task2.Result);
    }
    public static async Task<(T1, T2, T3)> WhenAll<T1, T2, T3>(Task<T1> task1, Task<T2> task2, Task<T3> task3)
    {
        await Task.WhenAll(task1, task2, task3);
        return (task1.Result, task2.Result, task3.Result);
    }
    ...
}}
```

## T4 のPros/Cons

Reference from [UfcppSample/Demo/2022/NoMoreT4 at master · ufcpp/UfcppSample](https://github.com/ufcpp/UfcppSample/tree/master/Demo/2022/NoMoreT4)

> 脱 T4 メリット
>
> - 速い
> - 普通の C# だけで書ける
>   - 補完・コード解析が働く
> - Visual Studio 以外で使える
>   - 「Visual Studio 上で保存時にコード生成」がきつかった
>   - この Roslyn Source Generator な時代に、誰も Source Generator 化しないあたりでお察し
> - csproj がすっきり
>   - `<None Update="T4Generator.tt">` みたいな謎タグ要らない
>   - `<Service Include="{508349b6-6b84-4df5-91f0-309beebad82d}" />` とかいう謎サービス要らない
>   - `<PackageReference Include="System.CodeDom" />` とかいうつらみあるパッケージ参照要らない
> - Visual Studio 自体のバージョン・表示言語に依存しない
>   - TextTemplatingFilePreprocessor の生成結果はは「T4 ファイルを編集して保存した PC」に依存しちゃう
>   - 複数人編集すると Git 差分が悲惨なことになってた
>
> 脱 T4 デメリット
>
> - 文字列補間、そこまできれいな文法じゃない
>   - T4 でもそこまで読みやすくはないんで、好みによるかも

## References

[Visual Studio 2022 17.5 Preview 2 - ufcpp YouTube](https://www.youtube.com/watch?v=_f6UA3Vs3Kc&t=3646s&ab_channel=ufcpp)  こちらの動画で 本Generator の存在を知りました

[dotnetconf2022-tokyo/RawStringLiterals.md at main ufcpp/dotnetconf2022-tokyo](https://github.com/ufcpp/dotnetconf2022-tokyo/blob/main/snippets/RawStringLiterals.md)

[NuGet Gallery | ScribanSourceGenerator 1.1.0](https://www.nuget.org/packages/ScribanSourceGenerator)

[ufcpp/ScribanSourceGenerator](https://github.com/ufcpp/ScribanSourceGenerator)

[scriban/scriban: A fast, powerful, safe and lightweight scripting language and engine for .NET](https://github.com/scriban/scriban)

[UfcppSample/Demo/2022/NoMoreT4 at master · ufcpp/UfcppSample](https://github.com/ufcpp/UfcppSample/tree/master/Demo/2022/NoMoreT4)  Pros/Cons,Benchmark
